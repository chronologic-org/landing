"use client"

import React, { useEffect, useRef, useState, useCallback } from "react"
import { SidebarButton } from "@/components/sidebar-button"
import { SortDropdown, type SortType } from "@/components/sort-dropdown"
import { SearchPanel } from "@/components/search-panel"
import { ConnectorsPanel } from "@/components/connectors-panel"
import { ProfilePanel } from "@/components/profile-panel"
import { SavedSearchesPanel } from "@/components/saved-searches-panel"
import { SettingsPanel } from "@/components/settings-panel"
import { AddPersonPanel } from "@/components/add-person-panel"
import * as planck from "planck"

interface Connection {
  id: number
  contactId?: string
  name: string
  title: string
  company: string
  industry: string
  photo: string
  linkedinUrl?: string
  bio?: string
  location?: string
  experience?: Array<{ title: string; company: string; location?: string; startDate?: string; endDate?: string; description?: string; isCurrent: boolean }>
  education?: Array<{ school: string; degree?: string; field?: string; startDate?: string; endDate?: string }>
  skills?: string[]
  languages?: string[]
  volunteering?: Array<{ role: string; organization: string; cause?: string; startDate?: string; endDate?: string }>
  certifications?: Array<{ name: string; issuingOrg: string; issueDate?: string; expirationDate?: string; credentialId?: string }>
}

interface TagData {
  id: string
  name: string
  color: string
}

interface ContactTagMapping {
  contact_id: string
  tag_id: string
  tag_name: string
  tag_color: string
}

interface ContactLinkData {
  id: string
  contact_a_id: string
  contact_b_id: string
}

interface NetworkGraphScreenProps {
  connections?: Connection[]
  sessionId?: string | null
  userPhoto?: string | null
  isPremium?: boolean
  hasUsedTrial?: boolean
  onShowSubscription?: () => void
  onCancelSubscription?: () => void
  isCancellingSubscription?: boolean
  onCsvUpload?: (file: File) => void
  isCsvUploading?: boolean
  csvError?: string | null
  onSubmitCredentials?: (email: string, password: string) => void
  onCancelSync?: () => void
  isSyncing?: boolean
  // Tags & links
  tags?: TagData[]
  contactTags?: ContactTagMapping[]
  contactLinks?: ContactLinkData[]
  onCreateTag?: (name: string) => Promise<TagData | null>
  onAddTag?: (contactId: string, tagId: string, tagInfo?: { name: string; color: string }) => void
  onRemoveTag?: (contactId: string, tagId: string) => void
  onCreateLink?: (contactAId: string, contactBId: string) => void
  onDeleteLink?: (contactAId: string, contactBId: string) => void
  // Contact overrides (user-specific profile edits)
  contactOverrides?: Map<string, any>
  onSaveOverride?: (contactId: string, fields: Record<string, any>) => void
  // Saved searches
  savedSearches?: Array<{ id: string; query: string; results: Array<{ id: string; name: string; title: string; company: string; industry: string; photo: string; linkedinUrl?: string; location?: string }>; savedAt: string }>
  onSaveSearch?: (query: string, results: Array<{ id: string; name: string; title: string; company: string; industry: string; photo: string; linkedinUrl?: string; location?: string }>) => void
  onDeleteSavedSearch?: (id: string) => void
  // Tag deletion
  onDeleteTag?: (tagId: string) => void
  // User info
  userName?: string | null
  // Add person
  onAddPerson?: (contact: { name: string; title: string; company: string; industry: string; location: string; bio: string; skills: string[]; experience: any[]; education: any[] }) => void
}

interface NodeData {
  id: string
  contactId?: string
  name: string
  photoUrl: string
  x: number
  y: number
  body?: planck.Body
  connectionCount?: number
  isYou?: boolean
  industry?: string
  title?: string
  company?: string
  groupId?: string
  linkedinUrl?: string
}

interface EdgeData {
  source: string
  target: string
  joint?: planck.DistanceJoint
  restLength?: number
  isUserLink?: boolean
}

interface SortGroup {
  id: string
  label: string
  count: number
  centerWorldX: number
  centerWorldY: number
  radiusWorld: number
  nodeIds: string[]
  color: string
}

// Desaturated, muted group colors
const groupColors = [
  "#d4908b", "#b095c8", "#7ba3c9", "#85b898", "#c9a57a",
  "#8ab8c9", "#c98a9a", "#c9b96e", "#c99a7f", "#a890c0",
  "#85b498", "#c99099", "#7ab0ab", "#c9b572", "#8e8db8",
  "#c48a96", "#8fc0d4", "#c9a06a", "#b0a48e", "#7fa8b4",
]

const ACCENT = "#5885ec"
const BG_COLOR = "#f0f1f3"

const SCALE = 30
const NODE_RADIUS = 0.4
const YOU_NODE_RADIUS = 0.8
const REPULSION_RADIUS = 3
const REPULSION_FORCE = 8
const CENTER_FORCE = 0.3
const LINK_FORCE = 0.85
const MAX_SORT_BUCKETS = 200
const LERP_SPEED = 0.10
const CIRCLE_SPACING = 0.85
const MIN_ZOOM = 0.35
const MAX_ZOOM = 2.5
const HOVER_PUSH_RADIUS = 2.0
const HOVER_SCALE = 1.7
const FADE_LERP = 0.08
const FADE_MIN = 0.45

/** Place N items in concentric circles around a center */
function circlePositions(count: number, cx: number, cy: number, spacing: number): Array<{ x: number; y: number }> {
  const positions: Array<{ x: number; y: number }> = []
  if (count === 0) return positions
  positions.push({ x: cx, y: cy })
  if (count === 1) return positions

  let placed = 1
  let ring = 1
  while (placed < count) {
    const circumference = 2 * Math.PI * ring * spacing
    // How many nodes fit on this ring (min spacing between nodes)
    const ringCap = Math.max(1, Math.floor(circumference / (spacing * 0.85)))
    const toPlace = Math.min(ringCap, count - placed)
    for (let i = 0; i < toPlace; i++) {
      const angle = (i / toPlace) * Math.PI * 2 - Math.PI / 2
      positions.push({
        x: cx + Math.cos(angle) * ring * spacing,
        y: cy + Math.sin(angle) * ring * spacing,
      })
      placed++
    }
    ring++
  }
  return positions
}

/** Calculate circle group radius in world units */
function circleRadiusWorld(count: number, spacing: number): number {
  if (count <= 1) return 1.2
  let placed = 1, ring = 1
  while (placed < count) {
    const circumference = 2 * Math.PI * ring * spacing
    const ringCap = Math.max(1, Math.floor(circumference / (spacing * 0.85)))
    placed += Math.min(ringCap, count - placed)
    if (placed < count) ring++
  }
  return Math.max(1.2, (ring + 0.5) * spacing)
}

export default function NetworkGraphScreen({ connections = [], userPhoto, isPremium, hasUsedTrial, onShowSubscription, onCancelSubscription, isCancellingSubscription, onCsvUpload, isCsvUploading, csvError, onSubmitCredentials, onCancelSync, isSyncing, tags = [], contactTags = [], contactLinks = [], onCreateTag, onAddTag, onRemoveTag, onCreateLink, onDeleteLink, contactOverrides = new Map(), onSaveOverride, savedSearches = [], onSaveSearch, onDeleteSavedSearch, onDeleteTag, userName, onAddPerson }: NetworkGraphScreenProps) {
  const canvasRef = useRef<HTMLCanvasElement>(null)
  const worldRef = useRef<planck.World | null>(null)
  const nodesRef = useRef<NodeData[]>([])
  const edgesRef = useRef<EdgeData[]>([])
  const draggedNodeRef = useRef<NodeData | null>(null)
  const hoveredNodeRef = useRef<NodeData | null>(null)
  const mouseJointRef = useRef<planck.MouseJoint | null>(null)
  const mouseDownPosRef = useRef<{ x: number; y: number; time: number } | null>(null)
  const groundBodyRef = useRef<planck.Body | null>(null)
  const animationRef = useRef<number>(0)
  const mousePosRef = useRef<{ x: number; y: number } | null>(null)
  const nodeImagesRef = useRef<Map<string, HTMLImageElement>>(new Map())
  const initializedRef = useRef<boolean>(false)
  const canvasSizeRef = useRef({ w: 800, h: 600 })

  const sortGroupsRef = useRef<SortGroup[]>([])
  const nodeTargetsRef = useRef<Map<string, { x: number; y: number }>>(new Map())
  const hasSortTargetsRef = useRef(false)
  // Per-node animated opacity for gradual fade
  const nodeOpacityRef = useRef<Map<string, number>>(new Map())
  // Track if user has manually panned/zoomed (disables auto-center drift)
  const userPannedRef = useRef(false)

  const zoomRef = useRef<number>(1)
  const panRef = useRef<{ x: number; y: number }>({ x: 0, y: 0 })
  const lastPinchDistRef = useRef<number | null>(null)
  const isPanningRef = useRef<boolean>(false)
  const lastPanPosRef = useRef<{ x: number; y: number } | null>(null)

  const [searchOpen, setSearchOpen] = useState(false)
  const [connectorsOpen, setConnectorsOpen] = useState(false)
  const [comingSoonButton, setComingSoonButton] = useState<"message" | null>(null)
  const [addPersonOpen, setAddPersonOpen] = useState(false)
  const [savedSearchesOpen, setSavedSearchesOpen] = useState(false)
  const [settingsOpen, setSettingsOpen] = useState(false)
  const [profileOpen, setProfileOpen] = useState(false)
  const [selectedProfile, setSelectedProfile] = useState<Connection | null>(null)
  // Resizable search panel width
  const [panelWidth, setPanelWidth] = useState(340)
  const isResizingRef = useRef(false)
  const MIN_PANEL_W = 260
  const MAX_PANEL_W = 600
  // Incremented when the physics world is created, so the render loop restarts
  const [worldVersion, setWorldVersion] = useState(0)
  // IDs of nodes matching current search query
  const searchMatchedIdsRef = useRef<Set<string>>(new Set())

  const toWorld = useCallback((px: number, py: number) => {
    const zoom = zoomRef.current, pan = panRef.current
    return planck.Vec2((px - pan.x) / (SCALE * zoom), (py - pan.y) / (SCALE * zoom))
  }, [])

  const toPixel = useCallback((wx: number, wy: number) => {
    const zoom = zoomRef.current, pan = panRef.current
    return { x: wx * SCALE * zoom + pan.x, y: wy * SCALE * zoom + pan.y }
  }, [])

  // Build sort groups with star arrangement, color-separated
  const createSortGroups = useCallback((sortType: SortType) => {
    if (!sortType) {
      nodesRef.current.forEach(node => { node.groupId = undefined })
      sortGroupsRef.current = []
      nodeTargetsRef.current.clear()
      hasSortTargetsRef.current = false
      userPannedRef.current = false
      nodesRef.current.forEach(node => {
        if (node.body) { node.body.setLinearVelocity(planck.Vec2(0, 0)); node.body.setLinearDamping(5) }
      })
      return
    }

    const nodes = nodesRef.current.filter(n => !n.isYou)

    // ===== INDUSTRY TAXONOMY: map freeform AI output → canonical buckets =====
    const INDUSTRY_ALIASES: Record<string, string[]> = {
      "Technology": ["tech", "information technology", "it", "software", "software development", "software engineering", "computer science", "computer software", "saas", "internet", "web development", "web", "it services", "it consulting", "information services", "cloud computing", "cloud", "devops", "platforms", "technology services", "high tech", "data infrastructure"],
      "Finance": ["financial services", "banking", "investment banking", "investment management", "investments", "wealth management", "asset management", "private equity", "venture capital", "vc", "hedge fund", "hedge funds", "capital markets", "financial", "finance & banking", "insurance", "accounting", "audit", "financial planning", "corporate finance", "commercial banking"],
      "FinTech": ["fintech", "financial technology", "payments", "digital payments", "neobank", "blockchain finance", "defi", "decentralized finance"],
      "Healthcare": ["health care", "health", "medical", "medicine", "hospital", "hospitals", "health services", "mental health", "public health", "pharmaceuticals", "pharma", "pharmaceutical", "biotech", "biotechnology", "life sciences", "medical devices", "clinical", "clinical research", "wellness", "health & wellness", "dental", "healthcare services", "health tech", "healthtech"],
      "Education": ["higher education", "academia", "academic", "edtech", "ed-tech", "educational technology", "k-12", "k12", "school", "university", "universities", "teaching", "research", "academic research", "training", "e-learning", "elearning", "learning"],
      "Consulting": ["management consulting", "strategy consulting", "strategy", "strategy & consulting", "business consulting", "advisory", "professional services", "business services"],
      "AI & Machine Learning": ["artificial intelligence", "ai", "ai/ml", "machine learning", "ml", "deep learning", "nlp", "natural language processing", "computer vision", "generative ai", "gen ai", "data science", "data analytics", "data", "big data", "analytics"],
      "Marketing & Advertising": ["marketing", "advertising", "digital marketing", "social media", "social media marketing", "content marketing", "brand", "branding", "public relations", "pr", "communications", "media", "media & entertainment", "creative", "creative agency", "growth marketing", "growth", "seo", "content"],
      "Real Estate": ["real estate", "property", "commercial real estate", "cre", "proptech", "property management", "property technology", "construction & real estate"],
      "E-Commerce & Retail": ["e-commerce", "ecommerce", "retail", "online retail", "d2c", "dtc", "direct to consumer", "consumer goods", "consumer products", "cpg", "fmcg", "shopping"],
      "Energy": ["energy", "oil & gas", "oil and gas", "petroleum", "renewable energy", "renewables", "clean energy", "solar", "wind", "utilities", "power", "cleantech", "clean tech", "sustainability", "environmental", "climate", "climate tech"],
      "Government & Public Sector": ["government", "public sector", "federal", "military", "defense", "defence", "civic tech", "public policy", "policy", "politics", "political", "nonprofit", "non-profit", "ngo", "civil service"],
      "Legal": ["law", "legal", "legal services", "law firm", "law practice", "attorney", "litigation", "compliance", "regulatory"],
      "Entertainment & Media": ["entertainment", "film", "music", "gaming", "video games", "esports", "media & entertainment", "broadcast", "streaming", "television", "tv", "movies", "animation", "content creation"],
      "Aerospace & Defense": ["aerospace", "aviation", "defense & aerospace", "space", "space tech", "satellite", "drones", "unmanned systems"],
      "Automotive": ["automotive", "auto", "electric vehicles", "ev", "autonomous vehicles", "mobility", "transportation"],
      "Food & Beverage": ["food", "food & beverage", "food and beverage", "f&b", "restaurant", "restaurants", "hospitality", "foodtech", "food tech", "agriculture", "agtech", "agritech", "farming"],
      "Construction": ["construction", "architecture", "engineering & construction", "building", "civil engineering", "infrastructure"],
      "Telecommunications": ["telecommunications", "telecom", "telco", "wireless", "5g", "networking"],
      "Manufacturing": ["manufacturing", "industrial", "supply chain", "logistics", "supply chain & logistics", "warehousing", "operations"],
      "Sports & Fitness": ["sports", "fitness", "athletics", "sports tech", "sportstech", "recreation", "outdoor"],
      "Fashion & Beauty": ["fashion", "beauty", "cosmetics", "apparel", "luxury", "luxury goods", "textile", "textiles"],
      "Travel & Hospitality": ["travel", "tourism", "hospitality", "hotels", "airline", "airlines"],
      "Cybersecurity": ["cybersecurity", "cyber security", "infosec", "information security", "security", "network security"],
      "Blockchain & Crypto": ["blockchain", "crypto", "cryptocurrency", "web3", "nft", "decentralized", "defi"],
      "Design": ["design", "ux", "ui", "ux/ui", "ui/ux", "graphic design", "product design", "industrial design", "interior design", "visual design", "user experience"],
      "HR & Recruiting": ["human resources", "hr", "recruiting", "recruitment", "talent", "talent acquisition", "staffing", "people operations", "people ops"],
      "Sales": ["sales", "business development", "biz dev", "enterprise sales", "account management", "revenue"],
      "Nonprofit": ["nonprofit", "non-profit", "ngo", "philanthropy", "social impact", "social enterprise", "charity"],
      "Startups": ["startup", "startups", "start-up", "start-ups", "entrepreneurship", "venture", "early stage", "early-stage", "founder"],
    }

    // Build a reverse lookup: lowercase alias → canonical industry name
    const industryLookup = new Map<string, string>()
    for (const [canonical, aliases] of Object.entries(INDUSTRY_ALIASES)) {
      industryLookup.set(canonical.toLowerCase(), canonical)
      for (const alias of aliases) {
        industryLookup.set(alias.toLowerCase(), canonical)
      }
    }

    // ===== COMPANY NORMALIZATION =====
    const normalizeCompany = (raw: string): string => {
      let v = raw.trim()
      // Strip legal suffixes
      v = v.replace(/\s*,?\s*(inc\.?|llc\.?|ltd\.?|corp\.?|co\.?|plc\.?|gmbh|s\.?a\.?|l\.?p\.?|incorporated|limited|corporation|company)$/i, "")
      // Strip "The " prefix
      v = v.replace(/^the\s+/i, "")
      v = v.replace(/\s+/g, " ").trim()
      return v
    }

    // Known company aliases (lowercase → canonical display name)
    const COMPANY_ALIASES: Record<string, string> = {
      "alphabet": "Google", "google llc": "Google", "google inc": "Google",
      "meta platforms": "Meta", "facebook": "Meta", "fb": "Meta",
      "amazon.com": "Amazon", "aws": "Amazon",
      "microsoft corporation": "Microsoft",
      "apple inc": "Apple",
      "ibm corporation": "IBM", "international business machines": "IBM",
      "jpmorgan chase": "JPMorgan", "jp morgan": "JPMorgan", "jpmorgan chase & co": "JPMorgan", "chase": "JPMorgan",
      "goldman sachs group": "Goldman Sachs", "gs": "Goldman Sachs",
      "mckinsey & company": "McKinsey", "mckinsey and company": "McKinsey",
      "boston consulting group": "BCG",
      "deloitte touche tohmatsu": "Deloitte", "deloitte consulting": "Deloitte",
      "ernst & young": "EY", "ernst and young": "EY",
      "pricewaterhousecoopers": "PwC", "pwc": "PwC",
      "kpmg international": "KPMG",
    }

    // ===== TITLE NORMALIZATION =====
    const normalizeTitle = (raw: string): string => {
      let v = raw.trim()
      // Strip seniority prefixes to group by core role
      v = v.replace(/^(senior|sr\.?|junior|jr\.?|lead|principal|staff|chief|head of|vp of|vp|director of|associate|assistant|intern -|entry[- ]level)\s+/i, "")
      // Normalize common abbreviations
      v = v.replace(/\beng\.?\b/i, "Engineer")
      v = v.replace(/\bmgr\.?\b/i, "Manager")
      v = v.replace(/\bdev\.?\b/i, "Developer")
      v = v.replace(/\bswe\b/i, "Software Engineer")
      v = v.replace(/\bpm\b/i, "Product Manager")
      v = v.replace(/\bceo\b/i, "CEO")
      v = v.replace(/\bcto\b/i, "CTO")
      v = v.replace(/\bcfo\b/i, "CFO")
      v = v.replace(/\bcoo\b/i, "COO")
      v = v.replace(/\bcmo\b/i, "CMO")
      // Strip trailing "I", "II", "III", "IV" levels
      v = v.replace(/\s+(I{1,3}|IV|V)$/i, "")
      v = v.replace(/\s+/g, " ").trim()
      return v
    }

    // ===== CORE NORMALIZE: dispatches to type-specific logic =====
    const normalizeValue = (raw: string, type: SortType): string => {
      if (!raw) return "Unknown"
      let v = raw.trim()
      // Collapse blank, N/A, Unknown, Unspecified, Not Specified, None, etc.
      if (/^(n\/?a|unknown|unspecified|not\s*specified|none|other|--|—|-|\.|\s*|tbd|tba)$/i.test(v)) return "Unknown"

      if (type === "industry") {
        // Try direct lookup first
        const directMatch = industryLookup.get(v.toLowerCase())
        if (directMatch) return directMatch
        // Try after stripping common noise words
        const stripped = v.replace(/^the\s+/i, "").replace(/\s*(industry|sector|services|solutions)\s*$/i, "").trim()
        const strippedMatch = industryLookup.get(stripped.toLowerCase())
        if (strippedMatch) return strippedMatch
        // Try each word as a standalone lookup (e.g., "SaaS Technology" → check "saas" → Technology)
        const words = stripped.toLowerCase().split(/[\s&/,]+/)
        for (const word of words) {
          const wordMatch = industryLookup.get(word)
          if (wordMatch) return wordMatch
        }
        // No taxonomy match — return cleaned value
        v = stripped.replace(/^the\s+/i, "")
        v = v.replace(/\s+/g, " ")
        return v
      }

      if (type === "company") {
        v = normalizeCompany(v)
        const aliasMatch = COMPANY_ALIASES[v.toLowerCase()]
        if (aliasMatch) return aliasMatch
        return v
      }

      if (type === "title") {
        v = normalizeTitle(v)
        return v
      }

      // Fallback
      v = v.replace(/^the\s+/i, "")
      v = v.replace(/\s+/g, " ")
      return v
    }

    // ===== Detect tag sort =====
    const isTagSort = typeof sortType === "string" && sortType.startsWith("tags:")
    const tagSortIds = isTagSort ? sortType.slice(5).split(",").filter(Boolean) : []
    const tagSortMetas = tagSortIds.map(id => tags.find(t => t.id === id)).filter(Boolean) as typeof tags
    // Keep single-tag compat reference for color
    const tagSortMeta = tagSortMetas.length === 1 ? tagSortMetas[0] : null

    // ===== BUILD GROUPS =====
    const canonMap = new Map<string, string>()
    const groups = new Map<string, NodeData[]>()

    if (isTagSort && tagSortIds.length > 0) {
      // Multi-tag sort: one group per selected tag, plus Untagged
      // Build lookup: tagId → set of contactIds
      const tagIdToContacts = new Map<string, Set<string>>()
      for (const tid of tagSortIds) {
        tagIdToContacts.set(tid, new Set<string>())
      }
      for (const ct of contactTags) {
        if (tagIdToContacts.has(ct.tag_id)) {
          tagIdToContacts.get(ct.tag_id)!.add(ct.contact_id)
        }
      }

      // Initialize groups for each selected tag + Untagged
      for (const meta of tagSortMetas) {
        groups.set(`#${meta.name}`, [])
      }
      groups.set("Untagged", [])

      // Assign each node to the first matching tag group
      const assigned = new Set<string>()
      nodes.forEach(node => {
        if (!node.contactId) { groups.get("Untagged")!.push(node); return }
        let placed = false
        for (const meta of tagSortMetas) {
          const contacts = tagIdToContacts.get(meta.id)
          if (contacts && contacts.has(node.contactId)) {
            groups.get(`#${meta.name}`)!.push(node)
            placed = true
            break
          }
        }
        if (!placed) groups.get("Untagged")!.push(node)
      })
    } else {
      // Standard sort (industry / title / company)
      nodes.forEach(node => {
        const raw = (node as any)[sortType as string] || "Unknown"
        const norm = normalizeValue(raw, sortType as "industry" | "title" | "company")
        const key = norm.toLowerCase()
        if (!canonMap.has(key)) canonMap.set(key, norm)
        const canon = canonMap.get(key)!
        if (!groups.has(canon)) groups.set(canon, [])
        groups.get(canon)!.push(node)
      })
    }

    // ===== FUZZY MERGE: skip for tag sorts (tag names are exact) =====
    if (!isTagSort) {
      const groupKeys = Array.from(groups.keys())

      // 1. Abbreviation merge (short names into longer ones)
      const abbrMerge = new Map<string, string>()
      for (const short of groupKeys) {
        if (short.length > 5 || short === "Unknown") continue
        const shortLower = short.toLowerCase()
        for (const long of groupKeys) {
          if (long === short || long.length <= short.length) continue
          const longLower = long.toLowerCase()
          if (longLower.includes(shortLower) ||
              longLower.split(/\s+/).map(w => w[0]).join("").toLowerCase() === shortLower) {
            abbrMerge.set(short, long)
            break
          }
        }
      }
      for (const [short, long] of abbrMerge) {
        const shortNodes = groups.get(short)
        if (shortNodes && groups.has(long)) {
          groups.get(long)!.push(...shortNodes)
          groups.delete(short)
        }
      }

      // 2. Substring merge: if one group name is entirely contained in another, merge into the shorter (more canonical) one
      const updatedKeys = Array.from(groups.keys()).filter(k => k !== "Unknown")
      const substringMerge = new Map<string, string>()
      for (let i = 0; i < updatedKeys.length; i++) {
        if (substringMerge.has(updatedKeys[i])) continue
        for (let j = i + 1; j < updatedKeys.length; j++) {
          if (substringMerge.has(updatedKeys[j])) continue
          const a = updatedKeys[i].toLowerCase(), b = updatedKeys[j].toLowerCase()
          if (a.includes(b)) {
            // b is contained in a → merge a into b (shorter/simpler name)
            substringMerge.set(updatedKeys[i], updatedKeys[j])
          } else if (b.includes(a)) {
            substringMerge.set(updatedKeys[j], updatedKeys[i])
          }
        }
      }
      for (const [from, to] of substringMerge) {
        const fromNodes = groups.get(from)
        if (fromNodes && groups.has(to)) {
          groups.get(to)!.push(...fromNodes)
          groups.delete(from)
        }
      }

      // 3. Plural merge: "Startups" → "Startup", "Engineers" → "Engineer"
      const pluralMerge = new Map<string, string>()
      const finalKeys = Array.from(groups.keys())
      for (const key of finalKeys) {
        if (key === "Unknown" || pluralMerge.has(key)) continue
        // Check if a singular/plural counterpart exists
        const lower = key.toLowerCase()
        let counterpart: string | undefined
        if (lower.endsWith("s") && lower.length > 3) {
          counterpart = finalKeys.find(k => k !== key && k.toLowerCase() === lower.slice(0, -1))
        } else {
          counterpart = finalKeys.find(k => k !== key && k.toLowerCase() === lower + "s")
        }
        if (counterpart) {
          // Merge the smaller group into the larger
          const keyCount = groups.get(key)?.length || 0
          const cpCount = groups.get(counterpart)?.length || 0
          if (keyCount >= cpCount) {
            pluralMerge.set(counterpart, key)
          } else {
            pluralMerge.set(key, counterpart)
          }
        }
      }
      for (const [from, to] of pluralMerge) {
        const fromNodes = groups.get(from)
        if (fromNodes && groups.has(to)) {
          groups.get(to)!.push(...fromNodes)
          groups.delete(from)
        }
      }
    }

    // ===== BUCKET OVERFLOW HANDLING (skip for tag sorts — only 2 groups) =====
    let topGroups: [string, NodeData[]][]
    let overflow: [string, NodeData[]][]

    if (isTagSort) {
      // Tag sort: keep both groups (tagged + Untagged), remove empty ones, sort by size like other sorts
      topGroups = Array.from(groups.entries())
        .filter(([, n]) => n.length > 0)
        .sort((a, b) => b[1].length - a[1].length)
      overflow = []
    } else {
      const sortedEntries = Array.from(groups.entries()).sort((a, b) => b[1].length - a[1].length)
      if (sortedEntries.length > MAX_SORT_BUCKETS) {
        topGroups = sortedEntries.filter(([, n]) => n.length >= 2)
        overflow = sortedEntries.filter(([, n]) => n.length < 2)
        if (topGroups.length > MAX_SORT_BUCKETS) {
          overflow.push(...topGroups.slice(MAX_SORT_BUCKETS))
          topGroups = topGroups.slice(0, MAX_SORT_BUCKETS)
        }
      } else {
        topGroups = sortedEntries
        overflow = []
      }
      // Always merge singletons into "Other" for cleaner layout
      const singletons = topGroups.filter(([label, n]) => n.length === 1 && label !== "Unknown")
      if (singletons.length > 10) {
        topGroups = topGroups.filter(([label, n]) => n.length > 1 || label === "Unknown")
        overflow.push(...singletons)
      }
      if (overflow.length > 0) {
        const other: NodeData[] = []
        overflow.forEach(([, gn]) => other.push(...gn))
        topGroups.push(["Other", other])
      }
    }

    const youNode = nodesRef.current.find(n => n.isYou)
    const cw = canvasSizeRef.current.w, ch = canvasSizeRef.current.h
    let centerWX: number, centerWY: number
    if (youNode?.body) {
      const yp = youNode.body.getPosition()
      centerWX = yp.x; centerWY = yp.y
    } else {
      centerWX = cw / 2 / SCALE; centerWY = ch / 2 / SCALE
    }

    // Separate "Other" (and "Untagged" in tag sorts) from regular groups — these wrap as outer rings
    const isOuterRingLabel = (label: string) => label === "Other" || (isTagSort && label === "Untagged")
    const otherEntry = topGroups.find(([label]) => isOuterRingLabel(label))
    const regularGroups = topGroups.filter(([label]) => !isOuterRingLabel(label))

    // Build regular groups with circle-based sizing
    const sortGroups: SortGroup[] = regularGroups.map(([label, groupNodes], index) => {
      const radiusW = circleRadiusWorld(groupNodes.length, CIRCLE_SPACING)
      const colorIdx = (index * 3) % groupColors.length

      // Determine group color
      let grpColor: string
      if (isTagSort) {
        // Match label (#tagname) to a tag meta for its color
        const matchedTag = tagSortMetas.find(t => `#${t.name}` === label)
        grpColor = matchedTag ? matchedTag.color : groupColors[colorIdx]
      } else {
        grpColor = groupColors[colorIdx]
      }

      return {
        id: `grp-${label}`, label, count: groupNodes.length,
        centerWorldX: 0, centerWorldY: 0,
        radiusWorld: radiusW,
        nodeIds: groupNodes.map(n => n.id),
        color: grpColor,
      }
    })
    regularGroups.forEach(([, groupNodes], i) => {
      groupNodes.forEach(node => { node.groupId = sortGroups[i].id })
    })

    // Place regular groups in rings around YOU
    // Each group gets angular space proportional to its size
    const LABEL_PAD = 0.6
    const GROUP_GAP = 0.4
    let placed = 0, ringIdx = 1, prevOuterEdge = 0
    while (placed < sortGroups.length) {
      const ringCap = ringIdx <= 1 ? 6 : ringIdx * 6
      const count = Math.min(ringCap, sortGroups.length - placed)
      const batch = sortGroups.slice(placed, placed + count)
      const effRadii = batch.map(g => g.radiusWorld + LABEL_PAD)
      const maxEffR = Math.max(...effRadii)
      const minFromPrev = prevOuterEdge + maxEffR + GROUP_GAP
      // Total arc needed: each group takes diameter + gap
      const totalArc = effRadii.reduce((s, r) => s + r * 2 + GROUP_GAP, 0)
      const circumR = totalArc / (2 * Math.PI)
      const ringR = Math.max(minFromPrev, circumR)
      // Assign angular share proportional to each group's effective diameter
      const weights = effRadii.map(r => r * 2 + GROUP_GAP)
      const totalWeight = weights.reduce((s, w) => s + w, 0)
      let cumAngle = -Math.PI / 2
      for (let i = 0; i < count; i++) {
        const halfArc = (weights[i] / totalWeight) * Math.PI
        const angle = cumAngle + halfArc
        batch[i].centerWorldX = centerWX + Math.cos(angle) * ringR
        batch[i].centerWorldY = centerWY + Math.sin(angle) * ringR
        cumAngle += halfArc * 2
      }
      prevOuterEdge = ringR + maxEffR
      placed += count; ringIdx++
    }

    // Wrap "Other" nodes around the entire constellation (well clear of labels)
    if (otherEntry) {
      const [, otherNodes] = otherEntry
      const otherOffset = prevOuterEdge + 2.0
      const otherGrp: SortGroup = {
        id: "grp-Other", label: "Other", count: otherNodes.length,
        centerWorldX: centerWX, centerWorldY: centerWY,
        radiusWorld: otherOffset,
        nodeIds: otherNodes.map(n => n.id),
        color: "#9ca3af",
      }
      otherNodes.forEach(node => { node.groupId = otherGrp.id })
      sortGroups.push(otherGrp)
    }
    sortGroupsRef.current = sortGroups

    // Compute circle target positions for regular groups
    const targets = new Map<string, { x: number; y: number }>()
    if (youNode) targets.set(youNode.id, { x: centerWX, y: centerWY })
    sortGroups.forEach(grp => {
      if (grp.label === "Other") return
      const grpNodes = grp.nodeIds.map(id => nodesRef.current.find(n => n.id === id)).filter(Boolean) as NodeData[]
      const positions = circlePositions(grpNodes.length, grp.centerWorldX, grp.centerWorldY, CIRCLE_SPACING)
      grpNodes.forEach((node, i) => { if (positions[i]) targets.set(node.id, positions[i]) })
    })

    // Place Other nodes in ring(s) wrapping around all groups
    if (otherEntry) {
      const [, otherNodes] = otherEntry
      let ringR = prevOuterEdge + 2.0
      let otherPlaced = 0
      while (otherPlaced < otherNodes.length) {
        const circ = 2 * Math.PI * ringR
        const ringCap = Math.max(1, Math.floor(circ / CIRCLE_SPACING))
        const toPlace = Math.min(ringCap, otherNodes.length - otherPlaced)
        for (let i = 0; i < toPlace; i++) {
          const angle = (i / toPlace) * Math.PI * 2 - Math.PI / 2
          targets.set(otherNodes[otherPlaced + i].id, {
            x: centerWX + Math.cos(angle) * ringR,
            y: centerWY + Math.sin(angle) * ringR,
          })
        }
        otherPlaced += toPlace
        ringR += 0.8
      }
    }
    nodeTargetsRef.current = targets
    hasSortTargetsRef.current = true
    userPannedRef.current = false

    nodesRef.current.forEach(node => {
      if (node.body) { node.body.setLinearVelocity(planck.Vec2(0, 0)); node.body.setLinearDamping(10) }
    })

    // Auto-zoom to fit, centered on YOU
    let minX = centerWX, maxX = centerWX, minY = centerWY, maxY = centerWY
    sortGroups.forEach(g => {
      const r = g.radiusWorld + 2
      minX = Math.min(minX, g.centerWorldX - r); maxX = Math.max(maxX, g.centerWorldX + r)
      minY = Math.min(minY, g.centerWorldY - r); maxY = Math.max(maxY, g.centerWorldY + r)
    })
    const pad = 3
    minX -= pad; maxX += pad; minY -= pad; maxY += pad
    const spreadW = (maxX - minX) * SCALE, spreadH = (maxY - minY) * SCALE
    const fitZoom = Math.min(cw / spreadW, ch / spreadH, 1.0)
    zoomRef.current = Math.max(MIN_ZOOM, fitZoom)
    panRef.current = {
      x: cw / 2 - centerWX * SCALE * zoomRef.current,
      y: ch / 2 - centerWY * SCALE * zoomRef.current,
    }
  }, [contactTags, tags])

  const handleSortChange = useCallback((sortType: SortType) => {
    createSortGroups(sortType)
  }, [createSortGroups])

  /** Update matched search node IDs */
  const handleSearchResults = useCallback((matchedIds: string[]) => {
    searchMatchedIdsRef.current = new Set(matchedIds)
  }, [])

  // Initialize physics world
  useEffect(() => {
    const canvas = canvasRef.current
    if (!canvas || connections.length === 0 || initializedRef.current) return
    initializedRef.current = true

    const parent = canvas.parentElement
    const cw = parent ? parent.clientWidth : window.innerWidth
    const ch = parent ? parent.clientHeight : window.innerHeight
    canvasSizeRef.current = { w: cw, h: ch }
    const centerX = cw / 2, centerY = ch / 2

    const world = planck.World({ gravity: planck.Vec2(0, 0) })
    worldRef.current = world
    const ground = world.createBody()
    groundBodyRef.current = ground

    const nodeDataList: Omit<NodeData, "body" | "connectionCount">[] = []
    nodeDataList.push({
      id: "you", name: "YOU",
      photoUrl: userPhoto || "/placeholder-user.jpg",
      x: centerX, y: centerY, isYou: true,
    })

    // Wider initial spread so nodes aren't crammed together
    const maxRadius = Math.min(400, 80 + connections.length * 1.0)
    connections.forEach((conn, i) => {
      const angle = i * 2.39996323
      const radius = 40 + Math.random() * (maxRadius - 40)
      nodeDataList.push({
        id: `node-${conn.id}`, contactId: conn.contactId, name: conn.name,
        photoUrl: conn.photo && conn.photo !== "/placeholder.svg" ? conn.photo : "/placeholder-user.jpg",
        x: centerX + Math.cos(angle) * radius + (Math.random() - 0.5) * 20,
        y: centerY + Math.sin(angle) * radius + (Math.random() - 0.5) * 20,
        industry: conn.industry, title: conn.title, company: conn.company, linkedinUrl: conn.linkedinUrl,
      })
    })

    const nodes: NodeData[] = nodeDataList.map((node) => {
      const isYou = node.isYou === true
      const body = world.createDynamicBody({
        position: toWorld(node.x, node.y),
        linearDamping: isYou ? 6 : 5, angularDamping: 0.5,
      })
      body.createFixture({
        shape: planck.Circle(isYou ? YOU_NODE_RADIUS : NODE_RADIUS),
        density: isYou ? 8 : 3, friction: 0.3, restitution: 0.2,
      })
      return { ...node, body, connectionCount: 0 }
    })
    nodesRef.current = nodes

    if (nodes.length > 1) {
      let mnX = Infinity, mxX = -Infinity, mnY = Infinity, mxY = -Infinity
      nodes.forEach(n => {
        if (!n.body) return
        const pos = n.body.getPosition()
        const px = pos.x * SCALE, py = pos.y * SCALE
        if (px < mnX) mnX = px; if (px > mxX) mxX = px
        if (py < mnY) mnY = py; if (py > mxY) mxY = py
      })
      const sw = mxX - mnX + 60, sh = mxY - mnY + 60
      const fz = Math.min(cw / sw, ch / sh, 1.2)
      zoomRef.current = Math.max(MIN_ZOOM, Math.min(fz, 1.2))
      const midX = (mnX + mxX) / 2 * zoomRef.current
      const midY = (mnY + mxY) / 2 * zoomRef.current
      panRef.current = { x: cw / 2 - midX, y: ch / 2 - midY }
    }

    const batchSize = 20
    const loadBatch = (start: number) => {
      nodeDataList.slice(start, start + batchSize).forEach((node) => {
        if (!node.photoUrl || node.photoUrl === "/placeholder-user.jpg") return
        const img = new Image()
        img.crossOrigin = "anonymous"
        img.src = node.photoUrl
        img.onload = () => { nodeImagesRef.current.set(node.id, img) }
      })
      if (start + batchSize < nodeDataList.length) setTimeout(() => loadBatch(start + batchSize), 100)
    }
    loadBatch(0)
    edgesRef.current = []

    // Signal the render loop to (re)start now that the world exists
    setWorldVersion(v => v + 1)

  }, [connections, userPhoto, toWorld])

  // Cancel animation only on unmount
  useEffect(() => {
    return () => { cancelAnimationFrame(animationRef.current) }
  }, [])

  // Incrementally add new connections to the existing physics world
  useEffect(() => {
    const world = worldRef.current
    if (!world || !initializedRef.current) return

    // Use linkedinUrl and contactId for deduplication (not numeric id which can collide)
    const existingUrls = new Set(nodesRef.current.map(n => n.linkedinUrl).filter(Boolean))
    const existingContactIds = new Set(nodesRef.current.map(n => n.contactId).filter(Boolean))
    const existingNodeIds = new Set(nodesRef.current.map(n => n.id))
    const newConns = connections.filter(conn => {
      // Skip if we already have this connection by linkedinUrl or contactId
      if (conn.linkedinUrl && existingUrls.has(conn.linkedinUrl)) return false
      if (conn.contactId && existingContactIds.has(conn.contactId)) return false
      // Fallback: check by node id
      if (existingNodeIds.has(`node-${conn.id}`)) return false
      return true
    })
    if (newConns.length === 0) return

    // Position new nodes near the YOU node
    const youNode = nodesRef.current.find(n => n.isYou)
    let spawnX: number, spawnY: number
    if (youNode?.body) {
      const youPos = youNode.body.getPosition()
      spawnX = youPos.x
      spawnY = youPos.y
    } else {
      const { w: cw, h: ch } = canvasSizeRef.current
      const center = toWorld(cw / 2, ch / 2)
      spawnX = center.x
      spawnY = center.y
    }

    const updatedNodes = [...nodesRef.current]
    for (const conn of newConns) {
      const angle = Math.random() * Math.PI * 2
      const offset = 1.5 + Math.random() * 1.5
      const posX = spawnX + Math.cos(angle) * offset
      const posY = spawnY + Math.sin(angle) * offset

      const body = world.createDynamicBody({
        position: planck.Vec2(posX, posY),
        linearDamping: 5,
        angularDamping: 0.5,
      })
      body.createFixture({
        shape: planck.Circle(NODE_RADIUS),
        density: 3,
        friction: 0.3,
        restitution: 0.2,
      })

      const px = posX * SCALE
      const py = posY * SCALE
      updatedNodes.push({
        id: `node-${conn.id}`,
        contactId: conn.contactId,
        name: conn.name,
        photoUrl: conn.photo && conn.photo !== "/placeholder.svg" ? conn.photo : "/placeholder-user.jpg",
        x: px, y: py,
        industry: conn.industry,
        title: conn.title,
        company: conn.company,
        linkedinUrl: conn.linkedinUrl,
        body,
        connectionCount: 0,
      })
    }
    nodesRef.current = updatedNodes
  }, [connections, toWorld])

  // Sync user-defined contact links into edge data
  useEffect(() => {
    if (!worldRef.current || nodesRef.current.length === 0) return

    // Remove old user-link edges
    edgesRef.current = edgesRef.current.filter(e => !e.isUserLink)

    // Build contactId → nodeId lookup
    const contactToNode = new Map<string, string>()
    nodesRef.current.forEach(n => {
      if (n.contactId) contactToNode.set(n.contactId, n.id)
    })

    // Add new user-link edges
    for (const link of contactLinks) {
      const srcNodeId = contactToNode.get(link.contact_a_id)
      const tgtNodeId = contactToNode.get(link.contact_b_id)
      if (!srcNodeId || !tgtNodeId) continue
      // Avoid duplicates
      if (edgesRef.current.some(e => e.isUserLink && e.source === srcNodeId && e.target === tgtNodeId)) continue

      edgesRef.current.push({
        source: srcNodeId,
        target: tgtNodeId,
        restLength: 4.0, // Moderate rest length for user links
        isUserLink: true,
      })
    }
  }, [contactLinks])

  // Render loop
  useEffect(() => {
    const canvas = canvasRef.current
    const world = worldRef.current
    if (!canvas || !world) return

    const ctx = canvas.getContext("2d")
    if (!ctx) return

    const dpr = window.devicePixelRatio || 1
    const resizeCanvas = () => {
      const parent = canvas.parentElement
      const w = parent ? parent.clientWidth : window.innerWidth
      const h = parent ? parent.clientHeight : window.innerHeight
      canvasSizeRef.current = { w, h }
      canvas.width = w * dpr; canvas.height = h * dpr
      canvas.style.width = `${w}px`; canvas.style.height = `${h}px`
      ctx.setTransform(dpr, 0, 0, dpr, 0, 0)
    }
    resizeCanvas()
    window.addEventListener("resize", resizeCanvas)

    const getCenter = () => toWorld(canvasSizeRef.current.w / 2, canvasSizeRef.current.h / 2)

    const applyCenterForce = () => {
      const center = getCenter()
      for (const node of nodesRef.current) {
        if (!node.body) continue
        const diff = planck.Vec2.sub(center, node.body.getPosition())
        // YOU gets a much stronger pull to snap to center faster
        const mult = node.isYou ? 10 : CENTER_FORCE
        node.body.applyForceToCenter(planck.Vec2.mul(diff, mult), true)
      }
    }

    const applyRepulsion = () => {
      const nodes = nodesRef.current
      for (let i = 0; i < nodes.length; i++) {
        for (let j = i + 1; j < nodes.length; j++) {
          const nA = nodes[i], nB = nodes[j]
          if (!nA.body || !nB.body) continue
          const diff = planck.Vec2.sub(nB.body.getPosition(), nA.body.getPosition())
          const distance = diff.length()
          if (distance < REPULSION_RADIUS && distance > 0.01) {
            const force = (REPULSION_FORCE * (REPULSION_RADIUS - distance)) / distance
            const fv = planck.Vec2.mul(diff, -force / distance)
            nA.body.applyForceToCenter(fv, true)
            nB.body.applyForceToCenter(planck.Vec2.neg(fv), true)
          }
        }
      }
    }

    // Hover repulsion: push nearby nodes away (idle mode)
    const applyHoverRepulsion = (hovered: NodeData) => {
      if (!hovered.body) return
      const hPos = hovered.body.getPosition()
      for (const node of nodesRef.current) {
        if (!node.body || node.id === hovered.id) continue
        const diff = planck.Vec2.sub(node.body.getPosition(), hPos)
        const dist = diff.length()
        if (dist < HOVER_PUSH_RADIUS && dist > 0.01) {
          const push = (HOVER_PUSH_RADIUS - dist) * 12 / dist
          node.body.applyForceToCenter(planck.Vec2.mul(diff, push / dist), true)
        }
      }
    }

    const applySpringForces = () => {
      const draggedNode = draggedNodeRef.current
      for (const edge of edgesRef.current) {
        const src = nodesRef.current.find(n => n.id === edge.source)
        const tgt = nodesRef.current.find(n => n.id === edge.target)
        if (!src?.body || !tgt?.body || !edge.restLength) continue
        const diff = planck.Vec2.sub(tgt.body.getPosition(), src.body.getPosition())
        const len = diff.length()
        if (len < 0.01) continue
        const dir = planck.Vec2.mul(diff, 1 / len)
        const f = planck.Vec2.mul(dir, LINK_FORCE * 3 * (len - edge.restLength))
        if (draggedNode !== src) src.body.applyForceToCenter(f, true)
        if (draggedNode !== tgt) tgt.body.applyForceToCenter(planck.Vec2.neg(f), true)
      }
    }

    const getConnectedNodeIds = (nodeId: string): Set<string> => {
      const connected = new Set<string>()
      edgesRef.current.forEach(e => {
        if (e.source === nodeId) connected.add(e.target)
        if (e.target === nodeId) connected.add(e.source)
      })
      return connected
    }

    const drawRoundedRect = (x: number, y: number, w: number, h: number, r: number) => {
      ctx.beginPath()
      ctx.moveTo(x + r, y)
      ctx.lineTo(x + w - r, y)
      ctx.quadraticCurveTo(x + w, y, x + w, y + r)
      ctx.lineTo(x + w, y + h - r)
      ctx.quadraticCurveTo(x + w, y + h, x + w - r, y + h)
      ctx.lineTo(x + r, y + h)
      ctx.quadraticCurveTo(x, y + h, x, y + h - r)
      ctx.lineTo(x, y + r)
      ctx.quadraticCurveTo(x, y, x + r, y)
      ctx.closePath()
    }

    const render = () => {
      const cw = canvasSizeRef.current.w, ch = canvasSizeRef.current.h

      // Hover detection (before physics so push can apply)
      const mousePos = mousePosRef.current
      let hoveredNode: NodeData | null = null
      if (mousePos) {
        const mouseWorld = toWorld(mousePos.x, mousePos.y)
        for (const node of nodesRef.current) {
          if (!node.body) continue
          if (planck.Vec2.distance(node.body.getPosition(), mouseWorld) < NODE_RADIUS * 2.5) {
            hoveredNode = node; break
          }
        }
      }
      hoveredNodeRef.current = hoveredNode

      if (hasSortTargetsRef.current) {
        // LERP mode
        world.step(1 / 60)
        const targets = nodeTargetsRef.current
        const draggedId = draggedNodeRef.current?.id
        const hNode = hoveredNode
        const hTarget = hNode ? targets.get(hNode.id) : null

        for (const node of nodesRef.current) {
          if (!node.body || node.id === draggedId) continue
          const baseTarget = targets.get(node.id)
          if (!baseTarget) continue

          let tx = baseTarget.x, ty = baseTarget.y

          // Hover push: displace nearby targets away from hovered node
          if (hNode && hTarget && node.id !== hNode.id && !node.isYou) {
            const dx = baseTarget.x - hTarget.x
            const dy = baseTarget.y - hTarget.y
            const dist = Math.sqrt(dx * dx + dy * dy)
            if (dist < 1.5 && dist > 0.01) {
              const push = (1.5 - dist) * 0.35 / dist
              tx += dx * push
              ty += dy * push
            }
          }

          const pos = node.body.getPosition()
          node.body.setPosition(planck.Vec2(
            pos.x + (tx - pos.x) * LERP_SPEED,
            pos.y + (ty - pos.y) * LERP_SPEED,
          ))
          node.body.setLinearVelocity(planck.Vec2(0, 0))
        }

        // Only auto-recenter if user hasn't manually panned/zoomed
        if (!userPannedRef.current && !isPanningRef.current && !draggedNodeRef.current) {
          const youNode = nodesRef.current.find(n => n.isYou)
          if (youNode?.body) {
            const yp = youNode.body.getPosition()
            const tpx = cw / 2 - yp.x * SCALE * zoomRef.current
            const tpy = ch / 2 - yp.y * SCALE * zoomRef.current
            panRef.current = {
              x: panRef.current.x + (tpx - panRef.current.x) * 0.03,
              y: panRef.current.y + (tpy - panRef.current.y) * 0.03,
            }
          }
        }
      } else {
        // IDLE physics
        applyCenterForce()
        applyRepulsion()
        if (hoveredNode && !draggedNodeRef.current) applyHoverRepulsion(hoveredNode)
        applySpringForces()
        world.step(1 / 60)
      }

      // Dynamic cursor
      if (draggedNodeRef.current) canvas.style.cursor = "grabbing"
      else if (hoveredNode) canvas.style.cursor = "pointer"
      else canvas.style.cursor = "default"

      ctx.fillStyle = BG_COLOR
      ctx.fillRect(0, 0, cw, ch)

      const sortGroups = sortGroupsRef.current

      // Draw group labels
      if (sortGroups.length > 0) {
        sortGroups.forEach((grp) => {
          const isOther = grp.label === "Other"
          const sp = toPixel(grp.centerWorldX, grp.centerWorldY)
          const sr = grp.radiusWorld * SCALE * zoomRef.current

          ctx.save()
          ctx.fillStyle = isOther ? "#9ca3af" : grp.color
          ctx.globalAlpha = isOther ? 0.6 : 0.85
          const fs = Math.max(9, 11 * zoomRef.current)
          ctx.font = `600 ${fs}px "Work Sans", system-ui, sans-serif`
          ctx.textAlign = "center"
          ctx.textBaseline = "bottom"
          // Other label at top of wrapping ring
          const labelY = isOther
            ? sp.y - sr - 6 * zoomRef.current
            : sp.y - sr - 6 * zoomRef.current
          ctx.fillText(`${grp.label} (${grp.count})`, sp.x, labelY)
          ctx.restore()
        })
      }

      const activeNode = draggedNodeRef.current || hoveredNode
      const connectedIds = activeNode ? getConnectedNodeIds(activeNode.id) : new Set<string>()

      // Draw edges
      edgesRef.current.forEach((edge) => {
        const src = nodesRef.current.find(n => n.id === edge.source)
        const tgt = nodesRef.current.find(n => n.id === edge.target)
        if (src?.body && tgt?.body && edge.restLength) {
          const sp = toPixel(src.body.getPosition().x, src.body.getPosition().y)
          const tp = toPixel(tgt.body.getPosition().x, tgt.body.getPosition().y)
          const dist = planck.Vec2.distance(src.body.getPosition(), tgt.body.getPosition())
          const tension = Math.max(0, Math.min(1, (dist / edge.restLength - 1) * 0.8))

          if (edge.isUserLink) {
            // User-defined links: lighter, dashed appearance
            ctx.save()
            ctx.setLineDash([4, 4])
            if (activeNode) {
              const isConn = edge.source === activeNode.id || edge.target === activeNode.id
              ctx.strokeStyle = isConn ? `rgba(88,133,236,0.5)` : "rgba(88,133,236,0.08)"
              ctx.lineWidth = isConn ? 1.2 : 0.6
            } else {
              ctx.strokeStyle = `rgba(88,133,236,${0.15 + tension * 0.1})`
              ctx.lineWidth = 0.8
            }
            ctx.beginPath(); ctx.moveTo(sp.x, sp.y); ctx.lineTo(tp.x, tp.y); ctx.stroke()
            ctx.restore()
          } else {
            if (activeNode) {
              const isConn = edge.source === activeNode.id || edge.target === activeNode.id
              ctx.strokeStyle = isConn ? `rgba(88,133,236,${0.7 + tension * 0.3})` : "rgba(0,0,0,0.03)"
              ctx.lineWidth = isConn ? Math.max(1, 1.5 - tension * 0.3) : 0.5
            } else {
              ctx.strokeStyle = `rgba(0,0,0,${0.08 + tension * 0.15})`
              ctx.lineWidth = Math.max(0.4, 1 - tension * 0.4)
            }
            ctx.beginPath(); ctx.moveTo(sp.x, sp.y); ctx.lineTo(tp.x, tp.y); ctx.stroke()
          }
        }
      })

      // Draw search edges: lines from YOU to each matched node
      const searchIds = searchMatchedIdsRef.current
      if (searchIds.size > 0) {
        const youNode = nodesRef.current.find(n => n.isYou)
        if (youNode?.body) {
          const youPos = youNode.body.getPosition()
          const youPx = toPixel(youPos.x, youPos.y)
          for (const matchId of searchIds) {
            const matchNode = nodesRef.current.find(n => n.id === matchId)
            if (!matchNode?.body) continue
            const mPos = matchNode.body.getPosition()
            const mPx = toPixel(mPos.x, mPos.y)
            const dist = planck.Vec2.distance(youPos, mPos)
            const alpha = Math.max(0.15, 0.5 - dist * 0.02)

            // Glow line
            ctx.save()
            ctx.strokeStyle = `rgba(88,133,236,${alpha * 0.4})`
            ctx.lineWidth = 3 * zoomRef.current
            ctx.beginPath(); ctx.moveTo(youPx.x, youPx.y); ctx.lineTo(mPx.x, mPx.y); ctx.stroke()
            ctx.restore()

            // Core line
            ctx.strokeStyle = `rgba(88,133,236,${alpha})`
            ctx.lineWidth = 1.2 * zoomRef.current
            ctx.beginPath(); ctx.moveTo(youPx.x, youPx.y); ctx.lineTo(mPx.x, mPx.y); ctx.stroke()

            // Gentle spring attraction toward YOU
            const diff = planck.Vec2.sub(youPos, mPos)
            const len = diff.length()
            if (len > 0.5) {
              const pull = planck.Vec2.mul(diff, 0.08)
              matchNode.body.applyForceToCenter(pull, true)
            }
          }
        }
      }

      const maxConn = Math.max(...nodesRef.current.map(n => n.connectionCount || 0), 1)

      // Draw nodes (YOU on top)
      const sortedNodes = [...nodesRef.current].sort((a, b) => {
        if (a.isYou) return 1; if (b.isYou) return -1; return 0
      })

      sortedNodes.forEach((node) => {
        if (!node.body) return
        const pos = node.body.getPosition()
        const p = toPixel(pos.x, pos.y)
        const isActive = activeNode && node.id === activeNode.id
        const isConnected = activeNode && connectedIds.has(node.id)
        const isYou = node.isYou === true
        const isHovered = hoveredNode && node.id === hoveredNode.id
        const connRatio = (node.connectionCount || 0) / Math.max(maxConn, 1)
        const baseRadius = isYou ? 20 * zoomRef.current : (11 + connRatio * 5) * zoomRef.current
        const radius = baseRadius * (isHovered && !isYou ? HOVER_SCALE : 1)

        const isSearchMatch = searchIds.size > 0 && searchIds.has(node.id)

        let grpColor: string | null = null
        if (!isYou && node.groupId && sortGroups.length > 0) {
          const grp = sortGroups.find(g => g.id === node.groupId)
          if (grp) grpColor = grp.color
        }

        // Compute target opacity (soft fade, not hard)
        let targetOpacity = 1
        let borderColor = grpColor || "#9ca3af"
        let borderWidth = isYou ? 2.5 : (grpColor ? 1.5 : 1)

        // Search-matched nodes get highlighted blue
        if (isSearchMatch) {
          borderColor = ACCENT
          borderWidth = 2.5
        }

        if (activeNode) {
          if (isActive) {
            borderColor = grpColor || ACCENT; borderWidth = isYou ? 3 : 2
          } else if (isConnected) {
            borderColor = ACCENT; borderWidth = isYou ? 2 : 1.5
          } else {
            targetOpacity = FADE_MIN; borderColor = grpColor || "rgba(0,0,0,0.1)"; borderWidth = isYou ? 1 : 0.5
          }
        }

        // Search match always stays fully visible and blue-bordered
        if (isSearchMatch) {
          targetOpacity = 1
          borderColor = ACCENT
          borderWidth = 2.5
        }

        // Gradually lerp opacity toward target
        const prevOpacity = nodeOpacityRef.current.get(node.id) ?? 1
        const opacity = prevOpacity + (targetOpacity - prevOpacity) * FADE_LERP
        nodeOpacityRef.current.set(node.id, opacity)

        // Search match glow
        if (isSearchMatch && !isYou) {
          ctx.save(); ctx.globalAlpha = 0.25
          ctx.beginPath(); ctx.arc(p.x, p.y, radius + 5 * zoomRef.current, 0, Math.PI * 2)
          ctx.fillStyle = ACCENT; ctx.fill(); ctx.restore()
        }

        // Group glow
        if (grpColor && !isYou && !isSearchMatch) {
          ctx.save(); ctx.globalAlpha = opacity * 0.15
          ctx.beginPath(); ctx.arc(p.x, p.y, radius + 4 * zoomRef.current, 0, Math.PI * 2)
          ctx.fillStyle = grpColor; ctx.fill(); ctx.restore()
        }
        if (isYou && opacity > 0.5) {
          ctx.save(); ctx.globalAlpha = 0.12
          ctx.beginPath(); ctx.arc(p.x, p.y, radius + 6 * zoomRef.current, 0, Math.PI * 2)
          ctx.fillStyle = ACCENT; ctx.fill(); ctx.restore()
        }

        const img = nodeImagesRef.current.get(node.id)
        if (img) {
          ctx.save(); ctx.globalAlpha = opacity
          ctx.beginPath(); ctx.arc(p.x, p.y, radius, 0, Math.PI * 2); ctx.closePath(); ctx.clip()
          ctx.drawImage(img, p.x - radius, p.y - radius, radius * 2, radius * 2)
          ctx.restore()
          ctx.save(); ctx.globalAlpha = opacity; ctx.strokeStyle = borderColor; ctx.lineWidth = borderWidth
          ctx.beginPath(); ctx.arc(p.x, p.y, radius, 0, Math.PI * 2); ctx.stroke(); ctx.restore()
        } else {
          ctx.save(); ctx.globalAlpha = opacity
          ctx.fillStyle = isYou ? ACCENT : (grpColor || "#9ca3af")
          ctx.beginPath(); ctx.arc(p.x, p.y, radius, 0, Math.PI * 2); ctx.fill()
          ctx.strokeStyle = borderColor; ctx.lineWidth = borderWidth; ctx.stroke(); ctx.restore()
          if (radius > 5) {
            ctx.save(); ctx.globalAlpha = opacity; ctx.fillStyle = "#ffffff"
            ctx.font = `600 ${Math.max(6, radius * 0.75)}px "Work Sans", system-ui, sans-serif`
            ctx.textAlign = "center"; ctx.textBaseline = "middle"
            ctx.fillText(node.name.charAt(0).toUpperCase(), p.x, p.y); ctx.restore()
          }
        }

        // YOU badge
        if (isYou) {
          ctx.save(); ctx.globalAlpha = 1
          const fs = Math.max(10, 12 * zoomRef.current)
          ctx.font = `600 ${fs}px "Work Sans", system-ui, sans-serif`
          ctx.textAlign = "center"; ctx.textBaseline = "top"
          const textY = p.y + radius + 5 * zoomRef.current
          const tw = ctx.measureText(node.name).width
          const padV = 4 * zoomRef.current
          const bw = tw + padV * 2, bh = fs + padV
          const bx = p.x - bw / 2, by = textY - padV / 2
          ctx.fillStyle = ACCENT; drawRoundedRect(bx, by, bw, bh, 3 * zoomRef.current); ctx.fill()
          ctx.fillStyle = "#ffffff"; ctx.fillText(node.name, p.x, textY); ctx.restore()
        }
      })

      // Hover tooltip
      const hNode = hoveredNodeRef.current
      if (hNode && !hNode.isYou && !draggedNodeRef.current && hNode.body) {
        const hPos = hNode.body.getPosition()
        const hPx = toPixel(hPos.x, hPos.y)
        const hRadius = (11 + ((hNode.connectionCount || 0) / Math.max(maxConn, 1)) * 5) * zoomRef.current * HOVER_SCALE
        const nameText = hNode.name || "", titleText = hNode.title || "", companyText = hNode.company || ""

        ctx.font = `600 12px "Work Sans", system-ui, sans-serif`
        const nameW = ctx.measureText(nameText).width
        ctx.font = `400 11px "Work Sans", system-ui, sans-serif`
        const titleW = ctx.measureText(titleText).width
        const companyW = ctx.measureText(companyText).width

        const padding = 12, lineH = 16
        let lineCount = 1
        if (titleText) lineCount++; if (companyText) lineCount++
        const contentW = Math.max(nameW, titleW, companyW)
        const ttW = contentW + padding * 2, ttH = lineCount * lineH + padding * 1.5

        let ttX = hPx.x - ttW / 2, ttY = hPx.y - hRadius - ttH - 10
        ttX = Math.max(4, Math.min(ttX, cw - ttW - 4))
        if (ttY < 4) ttY = hPx.y + hRadius + 10

        ctx.save(); ctx.shadowColor = "rgba(0,0,0,0.12)"; ctx.shadowBlur = 16; ctx.shadowOffsetY = 4
        ctx.fillStyle = "#ffffff"; drawRoundedRect(ttX, ttY, ttW, ttH, 8); ctx.fill(); ctx.restore()
        ctx.strokeStyle = `rgba(88,133,236,0.15)`; ctx.lineWidth = 1
        drawRoundedRect(ttX, ttY, ttW, ttH, 8); ctx.stroke()

        let ty = ttY + padding
        ctx.textAlign = "left"; ctx.textBaseline = "top"
        ctx.font = `600 12px "Work Sans", system-ui, sans-serif`; ctx.fillStyle = "#1a1a1a"
        ctx.fillText(nameText, ttX + padding, ty); ty += lineH
        if (titleText) {
          ctx.font = `400 11px "Work Sans", system-ui, sans-serif`; ctx.fillStyle = "#6b7280"
          ctx.fillText(titleText, ttX + padding, ty); ty += lineH
        }
        if (companyText) {
          ctx.font = `400 11px "Work Sans", system-ui, sans-serif`; ctx.fillStyle = ACCENT
          ctx.fillText(companyText, ttX + padding, ty)
        }
      }

      animationRef.current = requestAnimationFrame(render)
    }
    render()

    return () => { window.removeEventListener("resize", resizeCanvas); cancelAnimationFrame(animationRef.current) }
  }, [toPixel, toWorld, worldVersion])

  // Mouse handlers
  const handleMouseDown = useCallback((e: React.MouseEvent<HTMLCanvasElement>) => {
    const canvas = canvasRef.current, world = worldRef.current, ground = groundBodyRef.current
    if (!canvas || !world || !ground) return
    mouseDownPosRef.current = { x: e.clientX, y: e.clientY, time: Date.now() }
    const rect = canvas.getBoundingClientRect()
    const mw = toWorld(e.clientX - rect.left, e.clientY - rect.top)
    let clicked = false
    for (const node of nodesRef.current) {
      if (!node.body) continue
      if (planck.Vec2.distance(node.body.getPosition(), mw) < NODE_RADIUS * 2.5) {
        draggedNodeRef.current = node; clicked = true
        const j = world.createJoint(planck.MouseJoint({
          bodyA: ground, bodyB: node.body, target: mw,
          maxForce: 5000 * node.body.getMass(), frequencyHz: 5, dampingRatio: 0.9,
        }))
        mouseJointRef.current = j as planck.MouseJoint; break
      }
    }
    if (!clicked) { isPanningRef.current = true; lastPanPosRef.current = { x: e.clientX, y: e.clientY } }
  }, [toWorld])

  const handleMouseMove = useCallback((e: React.MouseEvent<HTMLCanvasElement>) => {
    const canvas = canvasRef.current
    if (!canvas) return
    const rect = canvas.getBoundingClientRect()
    mousePosRef.current = { x: e.clientX - rect.left, y: e.clientY - rect.top }
    if (isPanningRef.current && lastPanPosRef.current) {
      panRef.current = { x: panRef.current.x + e.clientX - lastPanPosRef.current.x, y: panRef.current.y + e.clientY - lastPanPosRef.current.y }
      lastPanPosRef.current = { x: e.clientX, y: e.clientY }; return
    }
    if (mouseJointRef.current) mouseJointRef.current.setTarget(toWorld(e.clientX - rect.left, e.clientY - rect.top))
  }, [toWorld])

  const handleMouseLeave = useCallback(() => {
    mousePosRef.current = null
    if (worldRef.current && mouseJointRef.current) worldRef.current.destroyJoint(mouseJointRef.current)
    mouseJointRef.current = null; draggedNodeRef.current = null
    isPanningRef.current = false; lastPanPosRef.current = null
  }, [])

  /** Open profile panel for a given connection */
  const openProfilePanel = useCallback((conn: Connection) => {
    setSelectedProfile(conn)
    setProfileOpen(true)
  }, [])

  /** Close profile panel */
  const closeProfilePanel = useCallback(() => {
    setProfileOpen(false)
    setSelectedProfile(null)
  }, [])

  /** Open user's own profile */
  const openUserProfile = useCallback(() => {
    const userConn: Connection = {
      id: -1,
      name: userName || "You",
      title: "",
      company: "",
      industry: "",
      photo: userPhoto || "/placeholder-user.jpg",
    }
    openProfilePanel(userConn)
  }, [userName, userPhoto, openProfilePanel])

  /** Handle profile selected from search results */
  const handleSelectProfile = useCallback((result: { id: string; name: string; title: string; company: string; industry: string; photo: string; linkedinUrl?: string; bio?: string; location?: string; experience?: any[]; education?: any[]; skills?: string[]; languages?: string[]; volunteering?: any[]; certifications?: any[] }) => {
    const numId = parseInt(result.id.replace("node-", ""), 10)
    const conn = connections.find(c => c.id === numId)
    if (conn) {
      openProfilePanel(conn)
    } else {
      openProfilePanel({
        id: numId,
        name: result.name,
        title: result.title,
        company: result.company,
        industry: result.industry || "Other",
        photo: result.photo,
        linkedinUrl: result.linkedinUrl,
        bio: result.bio,
        location: result.location,
        experience: result.experience,
        education: result.education,
        skills: result.skills,
        languages: result.languages,
        volunteering: result.volunteering,
        certifications: result.certifications,
      })
    }
  }, [connections, openProfilePanel])

  const handleMouseUp = useCallback((e: React.MouseEvent<HTMLCanvasElement>) => {
    // Mark user panned so auto-center stops
    if (isPanningRef.current) userPannedRef.current = true

    // Detect click (short distance + short time) on a node → open profile
    const down = mouseDownPosRef.current
    const dragged = draggedNodeRef.current
    if (down && dragged && !dragged.isYou) {
      const dx = e.clientX - down.x, dy = e.clientY - down.y
      const dist = Math.sqrt(dx * dx + dy * dy)
      const elapsed = Date.now() - down.time
      if (dist < 6 && elapsed < 400) {
        // Find the matching connection for this node
        const numId = parseInt(dragged.id.replace("node-", ""), 10)
        const conn = connections.find(c => c.id === numId)
        if (conn) openProfilePanel(conn)
      }
    }
    mouseDownPosRef.current = null

    if (worldRef.current && mouseJointRef.current) worldRef.current.destroyJoint(mouseJointRef.current)
    mouseJointRef.current = null; draggedNodeRef.current = null
    isPanningRef.current = false; lastPanPosRef.current = null
  }, [connections, openProfilePanel])

  const handleTouchStart = useCallback((e: React.TouchEvent<HTMLCanvasElement>) => {
    e.preventDefault()
    if (e.touches.length === 2) {
      const dx = e.touches[0].clientX - e.touches[1].clientX, dy = e.touches[0].clientY - e.touches[1].clientY
      lastPinchDistRef.current = Math.sqrt(dx * dx + dy * dy); return
    }
    const t = e.touches[0], canvas = canvasRef.current, world = worldRef.current, ground = groundBodyRef.current
    if (!canvas || !world || !ground || !t) return
    const rect = canvas.getBoundingClientRect()
    const tw = toWorld(t.clientX - rect.left, t.clientY - rect.top)
    for (const node of nodesRef.current) {
      if (!node.body) continue
      if (planck.Vec2.distance(node.body.getPosition(), tw) < NODE_RADIUS * 3) {
        draggedNodeRef.current = node
        const j = world.createJoint(planck.MouseJoint({
          bodyA: ground, bodyB: node.body, target: tw,
          maxForce: 5000 * node.body.getMass(), frequencyHz: 5, dampingRatio: 0.9,
        }))
        mouseJointRef.current = j as planck.MouseJoint; break
      }
    }
  }, [toWorld])

  const handleTouchMove = useCallback((e: React.TouchEvent<HTMLCanvasElement>) => {
    e.preventDefault()
    if (e.touches.length === 2) {
      const canvas = canvasRef.current; if (!canvas) return
      const rect = canvas.getBoundingClientRect()
      const dx = e.touches[0].clientX - e.touches[1].clientX, dy = e.touches[0].clientY - e.touches[1].clientY
      const cd = Math.sqrt(dx * dx + dy * dy)
      const cx = (e.touches[0].clientX + e.touches[1].clientX) / 2 - rect.left
      const cy = (e.touches[0].clientY + e.touches[1].clientY) / 2 - rect.top
      if (lastPinchDistRef.current !== null) {
        const nz = Math.min(Math.max(zoomRef.current * cd / lastPinchDistRef.current, MIN_ZOOM), MAX_ZOOM)
        const zc = nz / zoomRef.current
        panRef.current = { x: cx - (cx - panRef.current.x) * zc, y: cy - (cy - panRef.current.y) * zc }
        zoomRef.current = nz
      }
      lastPinchDistRef.current = cd; return
    }
    const t = e.touches[0], canvas = canvasRef.current, joint = mouseJointRef.current
    if (!canvas || !joint || !t) return
    const rect = canvas.getBoundingClientRect()
    joint.setTarget(toWorld(t.clientX - rect.left, t.clientY - rect.top))
  }, [toWorld])

  const handleTouchEnd = useCallback(() => {
    if (worldRef.current && mouseJointRef.current) worldRef.current.destroyJoint(mouseJointRef.current)
    mouseJointRef.current = null; draggedNodeRef.current = null; lastPinchDistRef.current = null
  }, [])

  const handleWheel = useCallback((e: React.WheelEvent<HTMLCanvasElement>) => {
    e.preventDefault()
    userPannedRef.current = true
    const canvas = canvasRef.current; if (!canvas) return
    const rect = canvas.getBoundingClientRect()
    const mx = e.clientX - rect.left, my = e.clientY - rect.top
    const nz = Math.min(Math.max(zoomRef.current * (e.deltaY > 0 ? 0.9 : 1.1), MIN_ZOOM), MAX_ZOOM)
    const zc = nz / zoomRef.current
    panRef.current = { x: mx - (mx - panRef.current.x) * zc, y: my - (my - panRef.current.y) * zc }
    zoomRef.current = nz
  }, [])

  /** Double-click a node to open their LinkedIn profile */
  const handleDoubleClick = useCallback((e: React.MouseEvent<HTMLCanvasElement>) => {
    const canvas = canvasRef.current
    if (!canvas) return
    const rect = canvas.getBoundingClientRect()
    const mw = toWorld(e.clientX - rect.left, e.clientY - rect.top)
    for (const node of nodesRef.current) {
      if (!node.body || node.isYou) continue
      if (planck.Vec2.distance(node.body.getPosition(), mw) < NODE_RADIUS * 2.5) {
        if (node.linkedinUrl) {
          window.open(node.linkedinUrl, "_blank", "noopener")
        }
        break
      }
    }
  }, [toWorld])

  /** Toggle search panel */
  const toggleSearch = useCallback(() => {
    setComingSoonButton(null)
    setSearchOpen(prev => {
      const next = !prev
      if (next) { setConnectorsOpen(false); setSettingsOpen(false); setAddPersonOpen(false) }
      if (!next) searchMatchedIdsRef.current = new Set()
      return next
    })
  }, [])

  /** Toggle connectors panel */
  const toggleConnectors = useCallback(() => {
    setComingSoonButton(null)
    setConnectorsOpen(prev => {
      const next = !prev
      if (next) {
        setSearchOpen(false); setSettingsOpen(false); setAddPersonOpen(false)
        searchMatchedIdsRef.current = new Set()
      }
      return next
    })
  }, [])

  /** Toggle settings panel */
  const toggleSettings = useCallback(() => {
    setComingSoonButton(null)
    setSettingsOpen(prev => {
      const next = !prev
      if (next) {
        setSearchOpen(false); setConnectorsOpen(false); setAddPersonOpen(false)
        searchMatchedIdsRef.current = new Set()
      }
      return next
    })
  }, [])

  /** Toggle saved searches panel */
  const toggleSavedSearches = useCallback(() => {
    setComingSoonButton(null)
    setSavedSearchesOpen(prev => !prev)
  }, [])

  /** Toggle add person panel */
  const toggleAddPerson = useCallback(() => {
    setComingSoonButton(null)
    setAddPersonOpen(prev => {
      const next = !prev
      if (next) {
        setSearchOpen(false); setConnectorsOpen(false); setSettingsOpen(false)
        searchMatchedIdsRef.current = new Set()
      }
      return next
    })
  }, [])

  /** Drag handle to resize the search panel */
  const handleResizeStart = useCallback((e: React.MouseEvent) => {
    e.preventDefault()
    isResizingRef.current = true
    const startX = e.clientX
    const startW = panelWidth
    const onMove = (ev: MouseEvent) => {
      if (!isResizingRef.current) return
      const delta = ev.clientX - startX
      setPanelWidth(Math.min(MAX_PANEL_W, Math.max(MIN_PANEL_W, startW + delta)))
    }
    const onUp = () => {
      isResizingRef.current = false
      document.removeEventListener("mousemove", onMove)
      document.removeEventListener("mouseup", onUp)
    }
    document.addEventListener("mousemove", onMove)
    document.addEventListener("mouseup", onUp)
  }, [panelWidth])

  return (
    <main className="w-screen h-screen overflow-hidden bg-[#f0f1f3] relative flex">
      {/* Sidebar — always visible, clean border */}
      <aside className="h-full w-14 shrink-0 z-20 bg-[#f0f1f3] border-r border-black/8 flex flex-col items-center py-3 gap-1 relative">
        {/* Add Person */}
        <SidebarButton icon="addPerson" onClick={toggleAddPerson} />
        <SidebarButton icon="search" onClick={toggleSearch} />
        <SidebarButton icon="savedSearches" onClick={toggleSavedSearches} />
        <SidebarButton icon="connectors" onClick={toggleConnectors} />
        <SidebarButton icon="settings" onClick={toggleSettings} />

        {/* Spacer to push user info to bottom */}
        <div className="flex-1" />

        {/* User info at bottom */}
        {userName && (
          <button
            onClick={openUserProfile}
            className="flex flex-col items-center gap-0.5 px-1 py-2 rounded-xl hover:bg-[#5885ec]/8 transition-all cursor-pointer w-full"
          >
            <div className="w-8 h-8 rounded-full overflow-hidden bg-[#e5e7eb] shrink-0">
              <img
                src={userPhoto || "/placeholder-user.jpg"}
                alt={userName}
                className="w-full h-full object-cover"
                onError={(e) => { (e.target as HTMLImageElement).src = "/placeholder-user.jpg" }}
              />
            </div>
            <span className="text-[8px] font-semibold text-[#4b5563] leading-tight text-center truncate w-full px-0.5">{userName}</span>
            <span className="text-[7px] text-[#9ca3af] leading-tight">{isPremium ? "Premium" : "Free"}</span>
          </button>
        )}
      </aside>

      {/* Search panel (slides out from sidebar edge, resizable) */}
      <div
        className="h-full z-20 overflow-hidden shrink-0 relative"
        style={{
          width: searchOpen ? panelWidth : 0,
          transition: isResizingRef.current ? "none" : "width 300ms ease-out",
        }}
      >
        <div className="h-full bg-white/95 backdrop-blur-md border-r border-black/5" style={{ width: panelWidth }}>
          <SearchPanel connections={connections} onResults={handleSearchResults} onClose={toggleSearch} onSelectProfile={handleSelectProfile} onSaveSearch={onSaveSearch} onOpenSavedSearches={() => setSavedSearchesOpen(true)} isPremium={isPremium} onShowSubscription={onShowSubscription} />
        </div>
        {/* Resize drag handle on right edge */}
        {searchOpen && (
          <div
            onMouseDown={handleResizeStart}
            className="absolute top-0 right-0 w-1.5 h-full cursor-col-resize z-30 group"
          >
            <div className="w-full h-full group-hover:bg-[#5885ec]/20 group-active:bg-[#5885ec]/30 transition-colors" />
          </div>
        )}
      </div>

      {/* Connectors panel (slides out from sidebar edge) */}
      <div
        className="h-full z-20 overflow-hidden shrink-0 relative"
        style={{
          width: connectorsOpen ? 300 : 0,
          transition: "width 300ms ease-out",
        }}
      >
        <div className="h-full bg-white/95 backdrop-blur-md border-r border-black/5" style={{ width: 300 }}>
          {onCsvUpload && (
            <ConnectorsPanel
              connections={connections}
              onCsvUpload={onCsvUpload}
              isCsvUploading={isCsvUploading}
              csvError={csvError}
              onClose={toggleConnectors}
              onSubmitCredentials={onSubmitCredentials}
              onCancelSync={onCancelSync}
              isSyncing={isSyncing}
            />
          )}
        </div>
      </div>

      {/* Settings panel (slides out from sidebar edge) */}
      <div
        className="h-full z-20 overflow-hidden shrink-0 relative"
        style={{
          width: settingsOpen ? 320 : 0,
          transition: "width 300ms ease-out",
        }}
      >
        <div className="h-full bg-white/95 backdrop-blur-md border-r border-black/5" style={{ width: 320 }}>
          <SettingsPanel
            tags={tags}
            contactLinks={contactLinks}
            connections={connections.map(c => ({ contactId: c.contactId, name: c.name }))}
            onCreateTag={onCreateTag}
            onDeleteTag={onDeleteTag}
            onDeleteLink={onDeleteLink}
            onClose={toggleSettings}
            userName={userName}
            userPhoto={userPhoto}
            isPremium={isPremium}
            onManageSubscription={onShowSubscription}
            onCancelSubscription={onCancelSubscription}
            isCancellingSubscription={isCancellingSubscription}
          />
        </div>
      </div>

      {/* Add Person panel (slides out from sidebar edge) */}
      <div
        className="h-full z-20 overflow-hidden shrink-0 relative"
        style={{
          width: addPersonOpen ? 340 : 0,
          transition: "width 300ms ease-out",
        }}
      >
        <div className="h-full bg-white/95 backdrop-blur-md border-r border-black/5" style={{ width: 340 }}>
          {onAddPerson && (
            <AddPersonPanel
              onAddPerson={onAddPerson}
              onClose={toggleAddPerson}
              isPremium={isPremium}
              onShowSubscription={onShowSubscription}
            />
          )}
        </div>
      </div>

      {/* Canvas + Saved Searches (vertical split) */}
      <div className="flex-1 h-full relative min-w-0 flex flex-col">
        {/* Canvas */}
        <div className={`relative min-h-0 ${savedSearchesOpen ? "flex-1" : "h-full"}`}>
          <canvas
            ref={canvasRef}
            className="w-full h-full"
            onMouseDown={handleMouseDown}
            onMouseMove={handleMouseMove}
            onMouseUp={handleMouseUp}
            onMouseLeave={handleMouseLeave}
            onWheel={handleWheel}
            onTouchStart={handleTouchStart}
            onTouchMove={handleTouchMove}
            onTouchEnd={handleTouchEnd}
            onDoubleClick={handleDoubleClick}
          />
        </div>

        {/* Saved Searches panel (bottom, slides up) */}
        <div
          className="shrink-0 overflow-hidden"
          style={{
            height: savedSearchesOpen ? "40%" : 0,
            maxHeight: savedSearchesOpen ? 400 : 0,
            transition: "height 300ms ease-out, max-height 300ms ease-out",
          }}
        >
          <SavedSearchesPanel
            savedSearches={savedSearches}
            onDelete={onDeleteSavedSearch}
            onClose={toggleSavedSearches}
            isPremium={isPremium}
            onShowSubscription={onShowSubscription}
          />
        </div>
      </div>

      {/* Profile panel (slides in from right side) */}
      <div
        className="h-full z-20 overflow-hidden shrink-0 relative"
        style={{
          width: profileOpen && selectedProfile ? 340 : 0,
          transition: "width 300ms ease-out",
        }}
      >
        <div className="h-full bg-white/95 backdrop-blur-md border-l border-black/5" style={{ width: 340 }}>
          {selectedProfile && (() => {
            const cid = selectedProfile.contactId
            // Merge user-specific overrides into profile data
            const override = cid ? contactOverrides.get(cid) : undefined
            const mergedProfile = override ? {
              ...selectedProfile,
              title: override.title || selectedProfile.title,
              company: override.company || selectedProfile.company,
              industry: override.industry || selectedProfile.industry,
              location: override.location || selectedProfile.location,
              bio: override.bio || selectedProfile.bio,
              experience: override.experience || selectedProfile.experience,
              education: override.education || selectedProfile.education,
              skills: override.skills || selectedProfile.skills,
              languages: override.languages || selectedProfile.languages,
              volunteering: override.volunteering || selectedProfile.volunteering,
              certifications: override.certifications || selectedProfile.certifications,
              hobbies: override.hobbies,
            } : selectedProfile
            // Compute assigned tags for this contact
            const assigned = cid
              ? contactTags
                  .filter(ct => ct.contact_id === cid)
                  .map(ct => ({ id: ct.tag_id, name: ct.tag_name, color: ct.tag_color }))
              : []
            // Compute linked contacts for this contact
            const linkedIds = new Set<string>()
            if (cid) {
              contactLinks.forEach(l => {
                if (l.contact_a_id === cid) linkedIds.add(l.contact_b_id)
                if (l.contact_b_id === cid) linkedIds.add(l.contact_a_id)
              })
            }
            const linked = connections
              .filter(c => c.contactId && linkedIds.has(c.contactId))
              .map(c => ({ id: c.id, contactId: c.contactId, name: c.name, photo: c.photo }))
            const allConts = connections
              .filter(c => c.contactId)
              .map(c => ({ id: c.id, contactId: c.contactId, name: c.name, photo: c.photo }))
            return (
              <ProfilePanel
                profile={mergedProfile}
                onClose={closeProfilePanel}
                tags={tags}
                assignedTags={assigned}
                onCreateTag={onCreateTag}
                onAddTag={onAddTag}
                onRemoveTag={onRemoveTag}
                linkedContacts={linked}
                allContacts={allConts}
                onCreateLink={onCreateLink}
                onDeleteLink={onDeleteLink}
                onSaveOverride={onSaveOverride}
              />
            )
          })()}
        </div>
      </div>

      {/* Get Pro pill — fixed top center */}
      {!isPremium && onShowSubscription && (
        <div className="fixed top-3 z-30 left-1/2 -translate-x-1/2">
          <button
            onClick={onShowSubscription}
            className="h-8 px-3.5 flex items-center gap-1.5 rounded-full
              bg-[#5885ec] border border-[#5885ec] text-white text-[11px] font-semibold
              hover:bg-[#5885ec] active:scale-[0.96]
              transition-all duration-150 cursor-pointer"
          >
            <svg width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round">
              <path d="M9.937 15.5A2 2 0 0 0 8.5 14.063l-6.135-1.582a.5.5 0 0 1 0-.962L8.5 9.936A2 2 0 0 0 9.937 8.5l1.582-6.135a.5.5 0 0 1 .963 0L14.063 8.5A2 2 0 0 0 15.5 9.937l6.135 1.582a.5.5 0 0 1 0 .962L15.5 14.063a2 2 0 0 0-1.437 1.437l-1.582 6.135a.5.5 0 0 1-.963 0z" />
              <path d="M20 3v4" /><path d="M22 5h-4" />
            </svg>
            {hasUsedTrial ? "Get Pro" : "Get Pro For Free"}
          </button>
        </div>
      )}

      {/* Sort dropdown — fixed to top-right of viewport, shifts left when profile panel is open */}
      <div
        className="fixed top-3 z-30 transition-all duration-300"
        style={{ right: profileOpen && selectedProfile ? 352 : 12 }}
      >
        <SortDropdown onSort={handleSortChange} tags={tags} />
      </div>
    </main>
  )
}
